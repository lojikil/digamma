; A simple collexion of useful utilities, that may over lap with init.ss, but
; to be used at my discresion...
;
; Scheme is like a ball of snow. You can add any amount of snow to it and it still looks like a ball of snow.
; Moreover, snow is cleaner than mud.
; -- Marc Feeley
(define-macro defn (name formals :body body)
	(list 'def name (cons 'fn (cons formals body))))
(define-macro define (name :body body)
	(if (eq? (type name) "Pair")
		(list 'def (car name) (cons fn (cons (cdr name) body)))
		(list 'def name (car body))))
(def null? (fn (n) (eq? n '())))
(def pair? (fn (n) (eq? (type n) "Pair")))
(def vector? (fn (n) (eq? (type n) "Vector")))
(def dict? (fn (n) (eq? (type n) "Dictionary")))
(def symbol? (fn (n) (eq? (type n) "Symbol")))
(def number? (fn (n) (eq? (type n) "Number")))
(def zero? (fn (n) (= n 0)))
(def eof-object? (fn (n) (eq? n #e)))
(def ncons (fn (x) (cons x '())))
(def unzip (fn (ll)
	(def inner-u-r (fn (xl yl sl)
		(if (null? sl)
			(list xl yl)
			(inner-u-r (append xl (ncons (car (car sl)))) (append yl (ncons (car (cdr (car sl))))) (cdr sl)))))
	(inner-u-r '() '() ll)))
(def zip (fn (xs ys)
	(if (null? xs)
		'()
		(cons (cons (car xs) (cons (car ys) '())) (zip (cdr xs) (cdr ys))))))
		
(define-macro and (<item> :rest <body>) 
	(if (null? <body>) 
		<item>
		(list 'if <item> (cons 'and <body>))))
(define-macro or (<item> :rest <body>) 
	(if (null? <body>)
		<item>
		(list 'if <item> #t (cons 'or <body>))))
(def endswith? (fn (ending str)
	(eq? (cslice str (- 0 (length ending)) -1) ending)))
(def beginswith? (fn (b str)
	(eq? (cslice str 0 (length b)) b)))
(define-macro with (name value :body body) (list (cons 'fn (cons (cons name '()) body)) value))
(define-macro let (bind :body letbody)
	((fn (unbounds) (cons (cons 'fn (cons (car unbounds) letbody)) (car (cdr unbounds)))) (unzip bind)))
(define-macro aif (<if-test> <if-true> :opt <if-false>) #f)

(defn but-last (lst)
	"remove everything but the last element"
	(if (null? (cdr lst))
		'()
		(cons (car lst) (but-last (cdr lst)))))
(define-macro cond (<if> <then> :rest <else>)
	(if (eq? <if> 'else)
		<then>
		(list 'if <if> <then> (append (ncons 'cond) <else>))))
(defn match (str pat) #f)
(defn split (str pat) #f)
(defn subst (str pat) #f)
(defn subst! (str pat) #f)
(defn map (proc col)
	(if (empty? col)
		col
		(ccons (proc (first col)) (map proc (rest col)))))
(defn filter (proc col)
	(if (empty? col)
		col
		(if (proc (first col))
			(ccons (first col) (filter proc (rest col)))
			(filter proc (rest col)))))
(defn map-apply (proc col)
	(if (empty? col)
		col
		(ccons (apply proc (first col)) (map-apply proc (rest col)))))
(def read-lines (fn (p)
	(with r (read-string p)
		(if (eof-object? r)
			'()
			(cons r (read-lines p))))))

(defn odd? (x)
	(= (modulo x 2) 1))
(defn even? (x)
	(= (modulo x 2) 0))
(defn foldr (op s l)
	(if (empty? l)
		s
		(op (first l) (foldr op s (rest l)))))
(defn foldl (op s l)
	(if (empty? l)
		s
		(foldl op (op s (first l)) (rest l))))
(def require (let ((paths ["~/.digamma/lib" "."]) (loaded {})) (fn (x) #f)))
