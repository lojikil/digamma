; A simple collexion of useful utilities, that may over lap with init.ss, but
; to be used at my discresion...
;
; Scheme is like a ball of snow. You can add any amount of snow to it and it still looks like a ball of snow.
; Moreover, snow is cleaner than mud.
; -- Marc Feeley
(define-macro defn (name formals :body body)
	(list 'def name (cons 'fn (cons formals body))))
(define-macro define (name :body body)
	(if (eq? (type name) "Pair")
		(list 'def (car name) (cons fn (cons (cdr name) body)))
		(list 'def name (car body))))
(def null? (fn (n) (eq? n '())))
(def pair? (fn (n) (eq? (type n) "Pair")))
(def vector? (fn (n) (eq? (type n) "Vector")))
(def dict? (fn (n) (eq? (type n) "Dictionary")))
(def symbol? (fn (n) (eq? (type n) "Symbol")))
(def key? (fn (n) (eq? (type n) "Key")))
(def number? (fn (n) (eq? (type n) "Number")))
(def string? (fn (n) (eq? (type n) "String")))
(def bool? (fn (n) (eq? (type n) "Boolean")))
(def goal? (fn (n) (eq? (type n) "Goal")))
(def not (fn (x)
        (cond
                (eq? x #s) #u
                (eq? x #f) #t
                (eq? x #u) #s
                else #f)))
(def zero? (fn (n) (= n 0)))
(def eof-object? (fn (n) (eq? n #e)))
(def ncons (fn (x) (cons x '())))
(def unzip (fn (ll)
	(def inner-u-r (fn (xl yl sl)
		(if (null? sl)
			(list xl yl)
			(inner-u-r (append xl (ncons (car (car sl)))) (append yl (ncons (car (cdr (car sl))))) (cdr sl)))))
	(inner-u-r '() '() ll)))
(def zip (fn (xs ys)
	(if (null? xs)
		'()
		(cons (cons (car xs) (cons (car ys) '())) (zip (cdr xs) (cdr ys))))))
		
(define-macro and (<item> :rest <body>) 
	(if (null? <body>) 
		<item>
		(list 'if <item> (cons 'and <body>))))
(define-macro or (<item> :rest <body>) 
	(if (null? <body>)
		<item>
		(list 'if <item> #t (cons 'or <body>))))
(def endswith? (fn (ending str)
	(eq? (cslice str (- 0 (length ending)) -1) ending)))
(def beginswith? (fn (b str)
	(eq? (cslice str 0 (length b)) b)))
(define-macro with (name value :body body) (list (cons 'fn (cons (cons name '()) body)) value))
(define-macro let (bind :body letbody)
	((fn (unbounds) (cons (cons 'fn (cons (car unbounds) letbody)) (car (cdr unbounds)))) (unzip bind)))
(define-macro aif (<if-test> <if-true> :opt <if-false>) #f)

(defn but-last (lst)
	"remove everything but the last element"
	(if (null? (cdr lst))
		'()
		(cons (car lst) (but-last (cdr lst)))))
(define-macro cond (<if> <then> :rest <else>)
	(if (eq? <if> 'else)
		<then>
		(list 'if <if> <then> (append (ncons 'cond) <else>))))
(defn match (str pat) #f)
(defn split (str pat) #f)
(defn subst (str pat) #f)
(defn subst! (str pat) #f)
(defn map (proc col)
	(if (empty? col)
		col
		(ccons (proc (first col)) (map proc (rest col)))))
(defn foreach-proc (proc col)
       (if (empty? col)
	       #v
	       (begin (proc (first col)) (map proc (rest col)))))
(defn filter (proc col)
	(if (empty? col)
		col
		(if (proc (first col))
			(ccons (first col) (filter proc (rest col)))
			(filter proc (rest col)))))
(defn map-apply (proc col)
	(if (empty? col)
		col
		(ccons (apply proc (first col)) (map-apply proc (rest col)))))
(def read-lines (fn (p)
	(with r (read-string p)
		(if (eof-object? r)
			'()
			(cons r (read-lines p))))))

(defn odd? (x)
	(= (modulo x 2) 1))
(defn even? (x)
	(= (modulo x 2) 0))
(defn foldr (op s l)
	(if (empty? l)
		s
		(op (first l) (foldr op s (rest l)))))
(defn foldl (op s l)
	(if (empty? l)
		s
		(foldl op (op s (first l)) (rest l))))
(def require (let ((paths ["~/.digamma/lib" "."]) (loaded {})) (fn (x) #f)))
(defn tilde-expand (f) ; need to flush this out & support ~user as well...
 (if (eq? (nth f 0) #\~)
  (string-append (sys :getenv "HOME") (cslice f 1 (length f)))
  f))
(def *lib-path* ["~/.digamma/lib" "."])
; Incredible inefficient definition of 'use, but works for now
(def use (with loaded {}
    (fn (l)
       (defn subuse (l paths)
        (if (eq? (sys :stat (string-append (tilde-expand (first paths)) "/" l)) #f)
         (subuse l (rest paths))
         (load (string-append (tilde-expand (first paths)) "/" l))))
      (subuse l *lib-path*)))) 
(def char->=? (fn (a b) (>= (coerce a 'int) (coerce b 'int))))
(def char->? (fn (a b) (> (coerce a 'int) (coerce b 'int))))
(def char-<=? (fn (a b) (<= (coerce a 'int) (coerce b 'int))))
(def char-<? (fn (a b) (< (coerce a 'int) (coerce b 'int))))
(defn char-range? (c start end)
	(and (>= (coerce c 'int) (coerce start 'int)) (<= (coerce c 'int) (coerce end 'int))))
(def caar (fn (x) (car (car x))))
(def cadr (fn (x) (car (cdr x))))
(def cdar (fn (x) (cdr (car x))))
(def cddr (fn (x) (cdr (cdr x))))
(def caaar (fn (x)( car (car (car x)))))
(def caadr (fn (x) (car (car (cdr x)))))
(def cadar (fn (x) (car (cdr (car x)))))
(def caddr (fn (x) (car (cdr (cdr x)))))
(def cdaar (fn (x) (cdr (car (car x)))))
(def cdadr (fn (x) (cdr (car (cdr x)))))
(def cddar (fn (x) (cdr (cdr (car x)))))
(def cdddr (fn (x) (cdr (cdr (cdr x)))))
(def caaaar (fn (x) (car (car (car (car x))))))
(def caaadr (fn (x) (car (car (car (cdr x))))))
(def caadar (fn (x) (car (car (cdr (car x))))))
(def caaddr (fn (x) (car (car (cdr (cdr x))))))
(def cadaar (fn (x) (car (cdr (car (car x))))))
(def cadadr (fn (x) (car (cdr (car (cdr x))))))
(def caddar (fn (x) (car (cdr (cdr (car x))))))
(def cadddr (fn (x) (car (cdr (cdr (cdr x))))))
(def cdaaar (fn (x) (cdr (car (car (car x))))))
(def cdaadr (fn (x) (cdr (car (car (cdr x))))))
(def cdadar (fn (x) (cdr (car (cdr (car x))))))
(def cdaddr (fn (x) (cdr (car (cdr (cdr x))))))
(def cddaar (fn (x) (cdr (cdr (car (car x))))))
(def cddadr (fn (x) (cdr (cdr (car (cdr x))))))
(def cdddar (fn (x) (cdr (cdr (cdr (car x))))))
(def cddddr (fn (x) (cdr (cdr (cdr (cdr x))))))
(def vector-equal? (fn (x y offset)
	(cond
		(>= offset (length x)) #t
		(equal? (nth x offset) (nth y offset)) (vector-equal? x y (+ offset 1))
		else #f)))
(def equal? (fn (x y)
	(cond
		(and (eq? (type x) "Pair") (eq? (type y) "Pair"))
			(if (equal? (car x) (car y))
				(equal? (cdr x) (cdr y))
				#f)
		(and (eq? (type x) "Vector") (eq? (type y) "Vector"))
			(if (= (length x) (length y))
				(vector-equal? x y 0)
				#f)
		(and (eq? (type x) "Number") (eq? (type y) "Number"))
			(= x y)
		else
			(eq? x y))))
