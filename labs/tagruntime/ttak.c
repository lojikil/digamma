/* this code was generated by E', the restricted Digamma compiler */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <gc.h>
#include <math.h>
#include <sys/param.h>
#include <fcntl.h>
#include <sys/time.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/socket.h>
#include <netdb.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <dirent.h>
#include <signal.h>
#include <errno.h>
#include <stdarg.h>
#include "vesta.h"
#define nil NULL
#define STRUE tl_env->strue
#define SFALSE tl_env->sfalse
#define SSUCC tl_env->ssucc
#define SUNSUCC tl_env->sunsucc
#define SNIL tl_env->snil
#define SSVOID tl_env->svoid

#define gmalloc GC_MALLOC

static Symbol *tl_env = nil;

SExp *tak(SExp *, SExp *, SExp *);
SExp *scheme_main();

SExp *makebool(char);
SExp *makeinteger(int);

Symbol *init_env(int);

void *hmalloc(size_t);

void clean();

typedef struct __MEM
{
    void *data;
    struct __MEM *next;
} MemoryList;

MemoryList *head = nil, *tail = nil;

SExp *
fprimsub(SExp *a, SExp *b)
{
    SExp *ret = makeinteger(a->object.n->nobject.z);
    AINT(ret) -= AINT(b);
    return ret;
}

SExp *
fprimgt(SExp *a, SExp *b)
{
    SExp *ret = makebool(0);
    ret->object.c = AINT(a) > AINT(b);
    return ret;
}

SExp * 
fprimprinc(SExp *o)
{
    if(o->type == STRING)
        printf("%s",o);
    else if(o->type == NUMBER)
        printf("%d",AINT(o));
    return SSVOID;
}

SExp *
makeinteger(int i)
{
    SExp *ret = nil;
    ret = (SExp *)gmalloc(sizeof(SExp));
    ret->type = NUMBER;
    ret->object.n = (Number *)gmalloc(sizeof(Number));
    NTYPE(ret) = INTEGER;
    AINT(ret) = i;
    return ret;
}

SExp *
makebool(char i)
{
    SExp *ret = nil;
    ret = (SExp *)gmalloc(sizeof(SExp));
    ret->type = BOOL;
    ret->object.c = (char)i & 0xFF;
    return ret;
}

Symbol *
init_env(int i)
{
    Symbol *r = nil;
    r = (Symbol *)gmalloc(sizeof(Symbol));
    r->strue = makebool(1);
    r->sfalse = makebool(0);
    r->svoid = (SExp *)gmalloc(sizeof(SExp));
    r->svoid->type = SVOID;
    r->snil = (SExp *)gmalloc(sizeof(SExp));
    r->snil->type = NIL;
    return r;
}

void
clean()
{
    MemoryList *h = head, *tmp = nil;
    while(h != nil)
    {
        tmp = h->next;
        free(h->data);
        free(h);
        h = tmp;
    }
}

void *
hmalloc(size_t sze)
{
    /* allocate the pointer, but add it to our "in use" list
     * not really anything other than a clean up mechanism 
     * really.
     */
    MemoryList *h = nil;
    void *object = malloc(sze);
    if(head == nil)
    {
        head = malloc(sizeof(MemoryList));
        h = head;
        tail = head;
        h->next = nil;
    }
    else
    {
        h = tail;
        h->next = malloc(sizeof(MemoryList));
        h = h->next;
        tail = h;
        tail->next = nil;
    }
    h->data = object;
    return object;
}

SExp *
tak(SExp *x,SExp *y,SExp *z)
{
	SExp *ret = nil, *x2 = nil,*y3 = nil,*z4 = nil;
    SExp *co119 = makeinteger(1);
	int s1 = 1;
	while(s1)
	{
        ret = SNIL;
        SExp *it5 = fprimgt(x,y);
		if(it5 == nil || it5->type == NIL || ((it5->type == BOOL || it5->type == GOAL) && it5->object.c))
        {
            x2 = tak(fprimsub(x,co119),y,z);
            y3 = tak(fprimsub(y,co119),z,x);
            z4 = tak(fprimsub(z,co119),x,y);
            x = x2;
            y = y3;
            z = z4;
        }
        else
        {
                s1 = 0;
                ret = y;
        }

	}
	return ret;
}

SExp *
scheme_main()
{
	SExp *ret = nil;
	ret = fprimprinc(tak(makeinteger(18),makeinteger(12),makeinteger(6)));
    printf("\n");
	return ret;
}

void
init_ctak()
{
    GC_INIT();
	tl_env = init_env(0);
}

int
main()
{
    init_ctak();
    scheme_main();
    clean();
    return 0;
}
